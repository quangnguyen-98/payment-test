from datetime import datetime
from decimal import Decimal
from typing import Any

from pydantic import BaseModel, Field, field_serializer, field_validator

from app.models.payment import PaymentStatus, PaymentTender
from app.schemas.base import BaseResponseSchema
from app.schemas.common import BaseFilter


class PaymentBase(BaseModel):
    """Base payment schema with common fields"""

    request_id: str | None = Field(default=None, description="External payment UUID")
    amount: Decimal = Field(..., ge=0, description="Payment amount")
    currency: str = Field(default="JPY", description="Payment currency")
    tender: PaymentTender = Field(default=PaymentTender.PAYPAY, description="Payment method")
    status: PaymentStatus | None = Field(
        default=PaymentStatus.PENDING, description="Payment status"
    )
    deeplink: str | None = Field(default=None, description="Payment provider deep link")
    txn_id: str | None = Field(default=None, description="Transaction ID from provider")
    expires_at: datetime | None = Field(default=None, description="Payment expiration time")
    terminal_id: int | None = Field(default=None, description="Terminal ID")

    @field_validator("amount")
    def validate_amount(cls, v):
        if v <= 0:
            raise ValueError("Amount must be positive")
        # Ensure 2 decimal places
        if v.as_tuple().exponent < -2:
            raise ValueError("Amount cannot have more than 2 decimal places")
        return v


class PaymentCreate(PaymentBase):
    """Schema for creating a payment"""

    pass  # ID is auto-generated by database


class PaymentUpdate(BaseModel):
    """Schema for updating a payment"""

    amount: Decimal | None = Field(default=None, ge=0)
    terminal_id: int | None = Field(default=None)
    status: PaymentStatus | None = Field(default=None)

    @field_validator("amount")
    def validate_amount(cls, v):
        if v is not None and v <= 0:
            raise ValueError("Amount must be positive")
        # Ensure 2 decimal places
        if v is not None and v.as_tuple().exponent < -2:
            raise ValueError("Amount cannot have more than 2 decimal places")
        return v


class PaymentResponse(PaymentBase, BaseResponseSchema):
    """Schema for payment response.

    Inherits from BaseResponseSchema which provides:
    - Common fields: id, created_at, updated_at, created_by, updated_by
    - Automatic handling of lazy-loaded relationships
    - DateTime serialization
    """

    pass


class PaymentFilter(BaseFilter):
    """Filter schema for payment queries"""

    status: PaymentStatus | list[PaymentStatus] | None = Field(
        default=None, description="Filter by status - can be single or multiple values"
    )
    terminal_id: int | list[int] | None = Field(
        default=None, description="Filter by terminal ID(s) - can be single or multiple values"
    )
    store_id: int | list[int] | None = Field(
        default=None, description="Filter by store ID(s) through terminal join"
    )
    payment_id: int | list[int] | None = Field(
        default=None, description="Filter by payment ID(s) - can be single or multiple values"
    )
    amount_gte: Decimal | None = Field(default=None, description="Filter by minimum amount")
    amount_lte: Decimal | None = Field(default=None, description="Filter by maximum amount")


# Forward references will be resolved when all schemas are loaded


class InitPaymentRequest(BaseModel):
    """Payment initialization request model."""

    request_id: str = Field(..., min_length=1, description="Unique payment request identifier")
    amount: int = Field(..., gt=0, description="Payment amount in minor currency units")
    currency: str = Field(..., min_length=1, description="Payment currency code")
    tender: str = Field(..., min_length=1, description="Payment method")
    terminal_id: int = Field(..., description="Terminal ID")
    store_id: int | None = Field(None, description="Store ID")
    merchant_id: int | None = Field(None, description="Merchant ID")
    psp_id: int | None = Field(None, description="PSP ID")
    payment_config: dict[str, Any] | None = Field(
        None, description="Payment provider specific configuration (e.g., paypay_merchant_id)"
    )


class PaymentStatusResponse(BaseModel):
    """Payment initialization response model."""

    request_id: str = Field(..., description="Payment request identifier")
    qr_string: str = Field(..., description="QR code SVG string")
    status: str = Field(..., description="Payment status")
    amount: int = Field(..., description="Payment amount")
    currency: str = Field(..., description="Payment currency")
    expires_at: datetime = Field(..., description="Payment expiration timestamp")
    txn_id: str | None = Field(None, description="Transaction ID when successful")

    @field_serializer("expires_at", when_used="json")
    def serialize_expires_at(self, dt: datetime, _info):
        return dt.strftime("%Y-%m-%dT%H:%M:%SZ")
